{"version":3,"sources":["model/hasone.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAOa;;;;;4BAEI,OAAO,UAAU;AAC9B,UAAI,sBACC,MADD,CAD0B;AAI9B,UAAI,OAAO,GAAP,IAAc,CAAC,OAAO,MAAP,EAAe;AAChC,eAAO,MAAP,GAAgB,OAAO,GAAP,CADgB;AAEhC,eAAO,OAAO,GAAP,CAFyB;OAAlC;AAIA,aAAO,MAAP,CAR8B;;;;AAWhC,WAbW,MAaX,CAAY,GAAZ,EAAiB;0BAbN,QAaM;;kEAbN,mBAcH,MADS;GAAjB;;eAbW;;mCAyBI,KAAK;AAClB,UAAM,aAAa,qBAAU,QAAV,CAAmB,GAAnB,uBAAb,CADY;AAElB,UAAI,CAAC,WAAW,KAAX,EAAkB;AACrB,cAAM,IAAI,KAAJ,CAAU,WAAW,QAAX,EAAV,CAAN,CADqB;OAAvB;;;;+BAKS,KAAK;AACd,UAAI,GAAJ,EAAS;AACP,mCAlCO,kDAkCU,IAAjB,CADO;;AAGP,YAAM,SAAS,KAAK,IAAL,gBAAgB,KAAK,IAAL,CAAhB,GAA6B,EAA7B,CAHR;;AAKP,YAAI,UAAU,IAAI,MAAJ,CALP;;AAOP,YAAI,kBAAJ,CAPO;AAQP,YAAI,OAAJ,EAAa;AACX,mBAAS,cAAT,CADW;AAEX,cAAI,MAAM,QAAQ,KAAR,0BAAN,CAFO;AAGX,iBAAO,MAAP,GAAgB,IAAI,CAAJ,KAAU,IAAI,MAAJ,CAHf;AAIX,iBAAO,KAAP,GAAe,IAAI,CAAJ,IAAS,yBAAU,IAAI,CAAJ,EAAO,IAAP,EAAV,CAAT,GAAoC,EAApC,CAJJ;SAAb;;AAOA,eAAO,OAAP,GAAiB,OAAjB,CAfO;AAgBP,eAAO,MAAP,GAAgB,MAAhB,CAhBO;;AAkBP,aAAK,IAAL,gBACK,OADL,CAlBO;OAAT;;;;;;;+BAyBS;AACT,UAAI,QAAQ,KAAK,IAAL,CADH;AAET,UAAI,iCA5DK,+CA4DL,CAFK;AAGT,aAAO,KAAK,KAAL,CAAW,KAAK,SAAL,cACb;AACH,gBAAQ,MAAM,MAAN,GAAe,MAAM,MAAN,CAAa,QAAb,EAAf,GAAyC,SAAzC;QAFQ,CAAX,CAAP,CAHS;;;;;;;6BAUF;AACP,UAAI,QAAQ,KAAK,IAAL,CADL;AAEP,UAAI,iCAtEK,6CAsEL,CAFG;AAGP,aAAO,KAAK,KAAL,CAAW,KAAK,SAAL,cACb;AACH,gBAAQ,MAAM,OAAN;QAFQ,CAAX,CAAP,CAHO;;;;wBAnDI;AACX,aAAO,KAAK,IAAL,GAAY,KAAK,IAAL,CAAU,MAAV,GAAmB,SAA/B,CADI;;;;wBAIH;AACR,aAAO,KAAK,IAAL,GAAY,KAAK,IAAL,CAAU,MAAV,GAAmB,SAA/B,CADC;;;;SArBC","file":"model/hasone.js","sourcesContent":["import {RefBase} from './refbase';\nimport {HasOneSchema} from '../schema';\nimport {validator} from '../validator';\nimport {REF_PATTERN} from './definitions';\nimport {Ref} from './ref';\nimport camelcase from 'camelcase';\n\nexport class HasOne extends RefBase {\n\n  static compose(props, children) {\n    let result = {\n      ...props,\n    };\n    if (result.ref && !result.hasOne) {\n      result.hasOne = result.ref;\n      delete result.ref;\n    }\n    return result;\n  }\n\n  constructor(obj) {\n    super(obj);\n  }\n\n  get hasOne() {\n    return this.$obj ? this.$obj.hasOne : undefined;\n  }\n\n  get ref() {\n    return this.$obj ? this.$obj.hasOne : undefined;\n  }\n\n  validateSchema(obj) {\n    const validation = validator.validate(obj, HasOneSchema);\n    if (!validation.valid) {\n      throw new Error(validation.toString());\n    }\n  }\n\n  updateWith(obj) {\n    if (obj) {\n      super.updateWith(obj);\n\n      const result = this.$obj ? {...this.$obj} : {};\n\n      let hasOne_ = obj.hasOne;\n\n      let hasOne;\n      if (hasOne_) {\n        hasOne = new Ref();\n        let res = hasOne_.match(REF_PATTERN);\n        hasOne.entity = res[1] || obj.entity;\n        hasOne.field = res[2] ? camelcase(res[2].trim()) : '';\n      }\n\n      result.hasOne_ = hasOne_;\n      result.hasOne = hasOne;\n\n      this.$obj = {\n        ...result\n      };\n    }\n  }\n\n  // it get fixed object\n  toObject() {\n    let props = this.$obj;\n    let res = super.toObject();\n    return JSON.parse(JSON.stringify({\n      ...res,\n      hasOne: props.hasOne ? props.hasOne.toString() : undefined,\n    }));\n  }\n\n  // it get clean object with no default values\n  toJSON() {\n    let props = this.$obj;\n    let res = super.toJSON();\n    return JSON.parse(JSON.stringify({\n      ...res,\n      hasOne: props.hasOne_,\n    }));\n  }\n}\n"],"sourceRoot":"/source/"}