{"version":3,"sources":["model/belongstomany.js"],"names":["BelongsToMany","props","children","result","ref","belongsToMany","obj","validation","validate","valid","Error","toString","$obj","belongsToMany_","using_","using","res","match","entity","field","trim","name","toLowerCase","name_","JSON","parse","stringify","undefined"],"mappings":"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","file":"model/belongstomany.js","sourcesContent":["import {RefBase} from './refbase';\nimport {BelongsToManySchema} from '../schema';\nimport {validator} from '../validator';\nimport {REF_PATTERN} from './definitions';\nimport {Ref} from './ref';\nimport camelcase from 'camelcase';\n\nexport class BelongsToMany extends RefBase {\n\n  static compose(props, children) {\n    let result = {\n      ...props,\n    };\n    if (result.ref && !result.belongsToMany) {\n      result.belongsToMany = result.ref;\n      delete result.ref;\n    }\n    return result;\n  }\n\n  constructor(obj) {\n    super(obj);\n  }\n\n  get belongsToMany() {\n    return this.$obj ? this.$obj.belongsToMany : undefined;\n  }\n\n  get using() {\n    return this.$obj ? this.$obj.using : undefined;\n  }\n\n  get ref() {\n    return this.$obj ? this.$obj.belongsToMany : undefined;\n  }\n\n  validateSchema(obj) {\n    const validation = validator.validate(obj, BelongsToManySchema);\n    if (!validation.valid) {\n      throw new Error(validation.toString());\n    }\n  }\n\n  updateWith(obj) {\n    if (obj) {\n      super.updateWith(obj);\n\n      const result = this.$obj ? {...this.$obj} : {};\n\n      let belongsToMany_ = obj.belongsToMany;\n\n      let using_ = obj.using;\n\n      let belongsToMany;\n      if (belongsToMany_) {\n        belongsToMany = new Ref();\n        let res = belongsToMany_.match(REF_PATTERN);\n        belongsToMany.entity = res[1] || obj.entity;\n        belongsToMany.field = res[2] ? camelcase(res[2].trim()) : '';\n      }\n\n      let using;\n      if (using_) {\n        using = new Ref();\n        let res = using_.match(REF_PATTERN);\n        using.entity = res[1] || obj.name || obj.entity;\n        using.field = res[2] ? camelcase(res[2].trim()) : obj.entity.toLowerCase();\n      } else {\n        using = new Ref(`${obj.name || obj.entity}#${obj.entity.toLowerCase()}`);\n      }\n\n      if (!obj.name_ && using) {\n        result.name = using.entity;\n      }\n\n      result.belongsToMany_ = belongsToMany_;\n      result.belongsToMany = belongsToMany;\n\n      result.using_ = using_;\n      result.using = using;\n\n      this.$obj = {\n        ...result\n      };\n    }\n  }\n  // it get fixed object\n  toObject() {\n    let props = this.$obj;\n    let res = super.toObject();\n    return JSON.parse(JSON.stringify({\n      ...res,\n      belongsToMany: props.belongsToMany ? props.belongsToMany.toString() : undefined,\n      using: props.using ? props.using.toString() : undefined,\n    }));\n  }\n\n  // it get clean object with no default values\n  toJSON() {\n    var props = this.$obj;\n    let res = super.toJSON();\n    return JSON.parse(JSON.stringify({\n      ...res,\n      belongsToMany: props.belongsToMany_,\n      using: props.using_,\n    }));\n  }\n}\n"],"sourceRoot":"/source/"}