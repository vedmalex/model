{"version":3,"sources":["model/belongsto.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAOa;;;;;4BAEI,OAAO,UAAU;AAC9B,UAAI,sBACC,MADD,CAD0B;AAI9B,UAAI,OAAO,GAAP,IAAc,CAAC,OAAO,SAAP,EAAkB;AACnC,eAAO,SAAP,GAAmB,OAAO,GAAP,CADgB;AAEnC,eAAO,OAAO,GAAP,CAF4B;OAArC;AAIA,aAAO,MAAP,CAR8B;;;;AAWhC,WAbW,SAaX,CAAY,GAAZ,EAAiB;0BAbN,WAaM;;kEAbN,sBAcH,MADS;GAAjB;;eAbW;;mCAyBI,KAAK;AAClB,UAAM,aAAa,qBAAU,QAAV,CAAmB,GAAnB,0BAAb,CADY;AAElB,UAAI,CAAC,WAAW,KAAX,EAAkB;AACrB,cAAM,IAAI,KAAJ,CAAU,WAAW,QAAX,EAAV,CAAN,CADqB;OAAvB;;;;+BAKS,KAAK;AACd,UAAI,GAAJ,EAAS;AACP,mCAlCO,qDAkCU,IAAjB,CADO;;AAGP,YAAM,SAAS,KAAK,IAAL,gBAAgB,KAAK,IAAL,CAAhB,GAA6B,EAA7B,CAHR;;AAKP,YAAI,aAAa,IAAI,SAAJ,CALV;;AAOP,YAAI,qBAAJ,CAPO;AAQP,YAAI,UAAJ,EAAgB;AACd,sBAAY,cAAZ,CADc;AAEd,cAAI,MAAM,WAAW,KAAX,0BAAN,CAFU;AAGd,oBAAU,MAAV,GAAmB,IAAI,CAAJ,KAAU,IAAI,MAAJ,CAHf;AAId,oBAAU,KAAV,GAAkB,IAAI,CAAJ,IAAS,yBAAU,IAAI,CAAJ,EAAO,IAAP,EAAV,CAAT,GAAoC,EAApC,CAJJ;SAAhB;;AAOA,eAAO,UAAP,GAAoB,UAApB,CAfO;AAgBP,eAAO,SAAP,GAAmB,SAAnB,CAhBO;;AAkBP,aAAK,IAAL,gBACK,OADL,CAlBO;OAAT;;;;;;;+BAyBS;AACT,UAAI,QAAQ,KAAK,IAAL,CADH;AAET,UAAI,iCA5DK,kDA4DL,CAFK;AAGT,aAAO,KAAK,KAAL,CAAW,KAAK,SAAL,cACb;AACH,mBAAW,MAAM,SAAN,GAAkB,MAAM,SAAN,CAAgB,QAAhB,EAAlB,GAA+C,SAA/C;QAFK,CAAX,CAAP,CAHS;;;;;;;6BAUF;AACP,UAAI,QAAQ,KAAK,IAAL,CADL;AAEP,UAAI,iCAtEK,gDAsEL,CAFG;AAGP,aAAO,KAAK,KAAL,CAAW,KAAK,SAAL,cACb;AACH,mBAAW,MAAM,UAAN;QAFK,CAAX,CAAP,CAHO;;;;wBAnDO;AACd,aAAO,KAAK,IAAL,GAAY,KAAK,IAAL,CAAU,SAAV,GAAsB,SAAlC,CADO;;;;wBAIN;AACR,aAAO,KAAK,IAAL,GAAY,KAAK,IAAL,CAAU,SAAV,GAAsB,SAAlC,CADC;;;;SArBC","file":"model/belongsto.js","sourcesContent":["import {RefBase} from './refbase';\nimport {BelongsToSchema} from '../schema';\nimport {validator} from '../validator';\nimport {REF_PATTERN} from './definitions';\nimport {Ref} from './ref';\nimport camelcase from 'camelcase';\n\nexport class BelongsTo extends RefBase {\n\n  static compose(props, children) {\n    let result = {\n      ...props,\n    };\n    if (result.ref && !result.belongsTo) {\n      result.belongsTo = result.ref;\n      delete result.ref;\n    }\n    return result;\n  }\n\n  constructor(obj) {\n    super(obj);\n  }\n\n  get belongsTo() {\n    return this.$obj ? this.$obj.belongsTo : undefined;\n  }\n\n  get ref() {\n    return this.$obj ? this.$obj.belongsTo : undefined;\n  }\n\n  validateSchema(obj) {\n    const validation = validator.validate(obj, BelongsToSchema);\n    if (!validation.valid) {\n      throw new Error(validation.toString());\n    }\n  }\n\n  updateWith(obj) {\n    if (obj) {\n      super.updateWith(obj);\n\n      const result = this.$obj ? {...this.$obj} : {};\n\n      let belongsTo_ = obj.belongsTo;\n\n      let belongsTo;\n      if (belongsTo_) {\n        belongsTo = new Ref();\n        let res = belongsTo_.match(REF_PATTERN);\n        belongsTo.entity = res[1] || obj.entity;\n        belongsTo.field = res[2] ? camelcase(res[2].trim()) : '';\n      }\n\n      result.belongsTo_ = belongsTo_;\n      result.belongsTo = belongsTo;\n\n      this.$obj = {\n        ...result\n      };\n    }\n  }\n\n  // it get fixed object\n  toObject() {\n    let props = this.$obj;\n    let res = super.toObject();\n    return JSON.parse(JSON.stringify({\n      ...res,\n      belongsTo: props.belongsTo ? props.belongsTo.toString() : undefined,\n    }));\n  }\n\n  // it get clean object with no default values\n  toJSON() {\n    let props = this.$obj;\n    let res = super.toJSON();\n    return JSON.parse(JSON.stringify({\n      ...res,\n      belongsTo: props.belongsTo_,\n    }));\n  }\n}\n"],"sourceRoot":"/source/"}