{"version":3,"sources":["model/entity.js"],"names":["Entity","props","children","fields","obj","modelPackage","identity","forEach","value","ids","get","identityFields","set","idKey","toString","modelRelations","relations","has","name","Map","ref","clone","missing","checkRelations","r","delete","field","relation","missingRef","entities","entity","e","fType","refe","using","replaceRef","toJSON","hasMany","belongsToMany","$obj","push","result","slice","toUpperCase","Set","required","indexed","f","Error","add","size","makeIdentity","res","JSON","parse","stringify","values","map","toObject","filter","undefined"],"mappings":"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","file":"model/entity.js","sourcesContent":["import {ModelBase} from './modelbase';\nimport {Field} from './field';\nimport {HasOne} from './hasone';\nimport {HasMany} from './hasmany';\nimport {BelongsTo} from './belongsto';\nimport {BelongsToMany} from './belongstomany';\nimport {DEFAULT_ID_FIELD} from './definitions';\n\nexport class Entity extends ModelBase {\n\n  static compose(props, children) {\n    if (props) {\n      return new Entity({\n      ...props,\n      fields: children,\n    });\n    } else {\n      return new Entity();\n    }\n  }\n\n  constructor(obj) {\n    super(obj);\n  }\n\n  ensureIds(modelPackage) {\n    this.identity.forEach((value)=> {\n      var ids = this.fields.get(value);\n      modelPackage.identityFields.set(ids.idKey.toString(), this);\n    });\n  }\n\n  ensureFKs(modelPackage) {\n    if (modelPackage) {\n      let modelRelations;\n      if (modelPackage.relations.has(this.name)) {\n        modelRelations = modelPackage.relations.get(this.name);\n      } else {\n        modelRelations = new Map();\n        modelPackage.relations.set(this.name, modelRelations);\n      }\n\n      this.relations.forEach((value)=> {\n        let ref = this.fields.get(value);\n        // must be different to apply fixup\n        modelRelations.set(ref.name, ref.clone());\n      });\n\n      let missing = this.checkRelations(modelPackage);\n      missing.forEach((r)=> {\n        modelRelations.delete(r.name);\n      });\n    }\n  }\n\n  checkRelations(modelPackage) {\n    let missing = [];\n    if (modelPackage.relations.has(this.name)) {\n      let modelRelations = modelPackage.relations.get(this.name);\n      modelRelations.forEach((field)=> {\n        let r = field.relation;\n        let missingRef = true;\n        if (!r.ref.field) {\n          // discover fieldName\n          if (modelPackage.entities.has(r.ref.entity)) {\n            let e = modelPackage.entities.get(r.ref.entity);\n            r.ref.field = e.identity[0];\n            missingRef = false;\n          }\n        }\n\n        const fType = (r instanceof HasOne) ? 'HasOne' : (r instanceof HasMany ? 'HasMany' : (r instanceof BelongsToMany ? 'BelongsToMany' : 'BelongsTo'));\n        switch (fType){\n          case 'HasOne':\n            if (modelPackage.entities.has(r.ref.entity)) {\n              let refe = modelPackage.entities.get(r.ref.entity);\n              if (relations.fields.has(r.ref.field)) {\n                missingRef = false;\n              }\n            }\n          break;\n          case 'HasMany':\n            // must be in ref store\n            if (modelPackage.entities.has(r.ref.entity)) {\n              let refe = modelPackage.entities.get(r.ref.entity);\n              if (refe.fields.has(r.ref.field)) {\n                missingRef = false;\n              }\n            }\n          break;\n          case 'BelongsToMany':\n            // must be in ref store\n            if (modelPackage.entities.has(r.ref.entity)) {\n              let refe = modelPackage.entities.get(r.ref.entity);\n              if (refe.fields.has(r.ref.field)) {\n                missingRef = false;\n              }\n            } else {\n              let using = r.using;\n              if (using && modelPackage.entities.has(using.entity)) {\n                // здесь нужно будет изменить тип ассоциации\n\n                let replaceRef = r.toJSON();\n                replaceRef.hasMany = replaceRef.using;\n\n                delete replaceRef.belongsToMany;\n                delete replaceRef.using;\n\n                field.$obj.relation = new HasMany(replaceRef);\n                missingRef = false;\n              }\n            }\n          break;\n          case 'BelongsTo':\n            // must be in identity store\n            if (modelPackage.identityFields.has(r.ref.toString())) {\n              missingRef = false;\n            }\n          break;\n        }\n\n        if (missingRef) {\n          missing.push(field);\n        }\n      });\n    }\n    return missing;\n  }\n\n  removeIds(modelPackage) {\n    this.identity.forEach((value)=> {\n      var ids = this.fields.get(value);\n      modelPackage.identityFields.delete(ids.idKey.toString());\n    });\n  }\n\n  get relations() {\n    return this.$obj ? this.$obj.relations : undefined;\n  }\n\n  get required() {\n    return this.$obj ? this.$obj.required : undefined;\n  }\n\n  get identity() {\n    return this.$obj ? this.$obj.identity : undefined;\n  }\n\n  get fields() {\n    return this.$obj ? this.$obj.fields : undefined;\n  }\n\n  get indexed() {\n    return this.$obj ? this.$obj.indexed : undefined;\n  }\n\n  updateWith(obj) {\n    if (obj) {\n      super.updateWith(obj);\n\n      const result = this.$obj ? {...this.$obj} : {};\n\n      result.name = (result.name.slice(0,1)).toUpperCase() + result.name.slice(1);\n\n      const fields = new Map();\n      const relations = new Set();\n      const identity = new Set();\n      const required = new Set();\n      const indexed = new Set();\n\n      obj.fields.forEach(f => {\n\n        let field = new Field({...f, entity: result.name});\n\n        if (fields.has(field.name)) {\n          throw new Error(`the same field ${field.name} is already exists in ${obj.name} entry`);\n        }\n\n        fields.set(field.name, field);\n\n        if (field.identity) {\n          identity.add(field.name);\n        }\n\n        if (field.required) {\n          required.add(field.name);\n        }\n\n        if (field.relation) {\n          relations.add(field.name);\n        }\n\n        if (field.indexed) {\n          indexed.add(field.name);\n        }\n\n      });\n\n      if (identity.size == 0) {\n        let f;\n        if (fields.has('id')) {\n          f = fields.get('id');\n        } else if (fields.has('_id')) {\n          f = fields.get('_id');\n        } else {\n          f = new Field({...DEFAULT_ID_FIELD, entity: result.name});\n          fields.set(f.name, f);\n        }\n\n        f.makeIdentity();\n        indexed.add(f.name);\n        identity.add(f.name);\n        required.add(f.name);\n      }\n\n      result.relations = relations;\n      result.identity = identity;\n      result.required = required;\n      result.indexed = indexed;\n      result.fields = fields;\n\n      this.$obj = {\n        ...result\n      };\n    }\n  }\n\n  toObject(modelPackage) {\n    if (!modelPackage) {\n      let props = this.$obj;\n      let res = super.toObject();\n      return JSON.parse(JSON.stringify({\n      ...res,\n      fields: [...props.fields.values()].map(f=> f.toObject()),\n    }));\n    } else {\n      let modelRelations = modelPackage.relations.get(this.name);\n      if (modelRelations) {\n        let props = this.$obj;\n        let res = super.toObject();\n        return JSON.parse(JSON.stringify({\n          ...res,\n          fields: [...props.fields.values()].map(f=> {\n            if (this.relations.has(f.name)) {\n              if (modelRelations.has(f.name)) {\n                return f.toObject(modelPackage);\n              }\n            } else {\n              return f.toObject(modelPackage);\n            }\n          }).filter(f=>f),\n        }));\n      }\n    }\n  }\n\n  toJSON(modelPackage) {\n    if (!modelPackage) {\n      let props = this.$obj;\n      let res = super.toJSON();\n      return JSON.parse(JSON.stringify({\n      ...res,\n      fields: [...props.fields.values()].map(f=> f.toJSON()),\n    }));\n    } else {\n      let modelRelations = modelPackage.relations.get(this.name);\n      if (modelRelations) {\n        let props = this.$obj;\n        let res = super.toJSON();\n        return JSON.parse(JSON.stringify({\n          ...res,\n          fields: [...props.fields.values()].map(f=> {\n            if (this.relations.has(f.name)) {\n              if (modelRelations.has(f.name)) {\n                return f.toJSON(modelPackage);\n              }\n            } else {\n              return f.toJSON(modelPackage);\n            }\n          }).filter(f=>f),\n        }));\n      }\n    }\n  }\n}\n"],"sourceRoot":"/source/"}